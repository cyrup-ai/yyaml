# 3.1.1. Dump

*Dumping* native data structures to a character [stream](https://yaml.org/spec/1.2.2/#streams) is done using the following three stages:

## Representing Native Data Structures

YAML *represents* any *native data structure* using three [node kinds](https://yaml.org/spec/1.2.2/#nodes): [sequence](https://yaml.org/spec/1.2.2/#sequence) - an ordered series of entries; [mapping](https://yaml.org/spec/1.2.2/#mapping) - an unordered association of [unique](https://yaml.org/spec/1.2.2/#node-comparison) [keys](https://yaml.org/spec/1.2.2/#nodes) to [values](https://yaml.org/spec/1.2.2/#nodes); and [scalar](https://yaml.org/spec/1.2.2/#scalar) - any datum with opaque structure presentable as a series of Unicode characters.

Combined, these primitives generate directed graph structures. These primitives were chosen because they are both powerful and familiar: the [sequence](https://yaml.org/spec/1.2.2/#sequence) corresponds to a Perl array and a Python list, the [mapping](https://yaml.org/spec/1.2.2/#mapping) corresponds to a Perl hash table and a Python dictionary. The [scalar](https://yaml.org/spec/1.2.2/#scalar) represents strings, integers, dates and other atomic data types.

Each YAML [node](https://yaml.org/spec/1.2.2/#nodes) requires, in addition to its [kind](https://yaml.org/spec/1.2.2/#nodes) and [content](https://yaml.org/spec/1.2.2/#nodes), a [tag](https://yaml.org/spec/1.2.2/#tags) specifying its data type. Type specifiers are either [global](https://yaml.org/spec/1.2.2/#tags) URIs or are [local](https://yaml.org/spec/1.2.2/#tags) in scope to a single [application](https://yaml.org/spec/1.2.2/#processes-and-models). For example, an integer is represented in YAML with a [scalar](https://yaml.org/spec/1.2.2/#scalar) plus the [global tag](https://yaml.org/spec/1.2.2/#tags) "`tag:yaml.org,2002:int`". Similarly, an invoice object, particular to a given organization, could be represented as a [mapping](https://yaml.org/spec/1.2.2/#mapping) together with the [local tag](https://yaml.org/spec/1.2.2/#tags) "`!invoice`". This simple model can represent any data structure independent of programming language.

## Serializing the Representation Graph

For sequential access mediums, such as an event callback API, a YAML [representation](https://yaml.org/spec/1.2.2/#representation-graph) must be *serialized* to an ordered tree. Since in a YAML [representation](https://yaml.org/spec/1.2.2/#representation-graph), [mapping keys](https://yaml.org/spec/1.2.2/#nodes) are unordered and [nodes](https://yaml.org/spec/1.2.2/#nodes) may be referenced more than once (have more than one incoming "arrow"), the serialization process is required to impose an [ordering](https://yaml.org/spec/1.2.2/#mapping-key-order) on the [mapping keys](https://yaml.org/spec/1.2.2/#nodes) and to replace the second and subsequent references to a given [node](https://yaml.org/spec/1.2.2/#nodes) with place holders called [aliases](https://yaml.org/spec/1.2.2/#anchors-and-aliases). YAML does not specify how these *serialization details* are chosen. It is up to the YAML [processor](https://yaml.org/spec/1.2.2/#processes-and-models) to come up with human-friendly [key order](https://yaml.org/spec/1.2.2/#mapping-key-order) and [anchor](https://yaml.org/spec/1.2.2/#anchors-and-aliases) names, possibly with the help of the [application](https://yaml.org/spec/1.2.2/#processes-and-models). The result of this process, a YAML [serialization tree](https://yaml.org/spec/1.2.2/#serialization-tree), can then be traversed to produce a series of event calls for one-pass processing of YAML data.

## Presenting the Serialization Tree

The final output process is *presenting* the YAML [serializations](https://yaml.org/spec/1.2.2/#serialization-tree) as a character [stream](https://yaml.org/spec/1.2.2/#streams) in a human-friendly manner. To maximize human readability, YAML offers a rich set of stylistic options which go far beyond the minimal functional needs of simple data storage. Therefore the YAML [processor](https://yaml.org/spec/1.2.2/#processes-and-models) is required to introduce various *presentation details* when creating the [stream](https://yaml.org/spec/1.2.2/#streams), such as the choice of [node styles](https://yaml.org/spec/1.2.2/#node-styles), how to [format scalar content](https://yaml.org/spec/1.2.2/#scalar-formats), the amount of [indentation](https://yaml.org/spec/1.2.2/#indentation-spaces), which [tag handles](https://yaml.org/spec/1.2.2/#tag-handles) to use, the [node tags](https://yaml.org/spec/1.2.2/#node-tags) to leave [unspecified](https://yaml.org/spec/1.2.2/#resolved-tags), the set of [directives](https://yaml.org/spec/1.2.2/#directives) to provide and possibly even what [comments](https://yaml.org/spec/1.2.2/#comments) to add. While some of this can be done with the help of the [application](https://yaml.org/spec/1.2.2/#processes-and-models), in general this process should be guided by the preferences of the user.